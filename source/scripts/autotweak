#!/bin/bash

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# For the complete terms of the GNU General Public License, please see this URL:
# http://www.gnu.org/licenses/gpl-3.0.html
#
# Copyright (c) 2024, Peter Laszlo
#

declare -A first_cpu_map

log() {
    local message=$1

    # Log the message with the script's basename as the tag
    logger  -t "$(basename "$0")" "$message"
    echo "$message"  > /dev/tty
}

#
# CPU and ASPM settings
#

set_scaling_governor() {
  local governor=$1

  # Check if the governor name is provided
  if [ -z "$governor" ]; then
    echo "Usage: set_scaling_governor [governor]"
    echo "governor: The CPU scaling governor to set (e.g., 'performance', 'powersave')"
    return 1
  fi

  # Iterate through each CPU core's scaling_governor file and set the governor
  for file in /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor; do
    local cpu_number=$(echo "$file" | grep -oP 'cpu\K\d+')
    if [ -w "$file" ]; then
      echo "$governor" > "$file"
      log "Set scaling governor to $governor for CPU $cpu_number"
    else
      log "Cannot write to $file, might require root privileges"
    fi
  done
}

set_cpu_performance_preference() {
  local preference=$1

  # Check if the preference parameter is provided
  if [ -z "$preference" ]; then
    echo "Usage: set_cpu_performance_preference [preference]"
    echo "preference: The performance preference to set (e.g., 'power', 'balance_power', 'balance_performance', 'performance', 'default')"
    return 1
  fi

  if [ -f "/sys/devices/system/cpu/cpu0/cpufreq/energy_performance_preference" ]; then

    # Iterate through each energy_performance_preference file and write the preference into it
    for file in /sys/devices/system/cpu/cpu*/cpufreq/energy_performance_preference; do
      local cpu_number=$(echo "$file" | grep -oP 'cpu\K\d+')
      if [ -w "$file" ]; then
        echo "$preference" > "$file"
        log "Set performance preference to $preference for CPU $cpu_number"
      else
        log "Cannot write to $file, might require root privileges"
      fi
    done

  elif [ -f "/sys/devices/system/cpu/cpu0/power/energy_perf_bias" ]; then

    # Convert performance to EBP value
    local bias
    case $preference  in
      'power')
        bias=15
        ;;
      'balance_power')
        bias=8
        ;;
      'balance_performance')
        bias=4
        ;;
      'performance')
        bias=0
        ;;
      'default')
        bias=6
        ;;
      esac

    # Iterate through each energy_perf_bias file and write the bias into it
    for file in /sys/devices/system/cpu/cpu*/power/energy_perf_bias; do
      local cpu_number=$(echo "$file" | grep -oP 'cpu\K\d+')
      if [ -w "$file" ]; then
        echo "$bias" > "$file"
        log "Set performance bias to $preference $bias for CPU $cpu_number"
      else
        log "Cannot write to $file, might require root privileges"
      fi
    done

  else
    log "Performance preference feature is not supported on this CPU"
    return 1
  fi
}

set_dynamic_boost() {
  local value=$1

  # Check if the input is provided and valid (0 or 1)
  if [ -z "$value" ]; then
    echo "Usage: set_dynamic_boost [value]"
    echo "value: The value for dynamic boost (0 or 1)"
    return 1
  fi

  if [[ "$value" != "0" && "$value" != "1" ]]; then
    echo "Error: invalid value: $value. Only '0' or '1' are allowed"
    return 1
  fi

  local file="/sys/devices/system/cpu/intel_pstate/hwp_dynamic_boost"

  if [ -f "$file" ]; then
    # Check if the file is writable
    if [ -w "$file" ]; then
      echo "$value" > "$file"
      log "Set HWP Dynamic Boost to $value"
      return 0
    else
      log "Cannot write to $file, might require root privileges"
      return 1
    fi
  fi

  file="/sys/devices/system/cpu/amd_pstate/cppc_dynamic_boost"

  if [ -f "$file" ]; then
    # Check if the file is writable
    if [ -w "$file" ]; then
      echo "$value" > "$file"
      log "Set CPPC Dynamic Boost to $value"
      return 0
    else
      log "Cannot write to $file, might require root privileges"
      return 1
    fi
  fi

  log "Dynamic Boost is not supported by the CPU"
  return 1
}

set_no_turbo() {
  local value=$1

  # Check if the input is provided and valid (0 or 1)
  if [ -z "$value" ]; then
    echo "Usage: set_no_turbo [value]"
    echo "value: The value for no_turbo (0 or 1)"
    return 1
  fi

  if [[ "$value" != "0" && "$value" != "1" ]]; then
    echo "Error: invalid value: $value. Only '0' or '1' are allowed"
    return 1
  fi

  local file="/sys/devices/system/cpu/intel_pstate/no_turbo"

  if [ -f "$file" ]; then
    # Check if the file is writable
    if [ -w "$file" ]; then
      echo "$value" > "$file"
      log "Set no_turbo to $value"
      return 0
    else
      log "Cannot write to $file, might require root privileges"
      return 1
    fi
  fi

  # Try legacy boost knob
  file="/sys/devices/system/cpu/cpufreq/boost"
  
  if [ -f "$file" ]; then
    value=$((value == 1 ? 0 : 1)) 

    # Check if the file is writable
    if [ -w "$file" ]; then
      echo "$value" > "$file"
      log "Set boost to $value"
      return 0
    else
      log "Cannot write to $file, might require root privileges"
      return 1
    fi
  fi

  log "Turbo/Boost is not supported by the CPU"
  return 1
}

set_aspm_policy() {
  local policy=$1

  if [ -z "$policy" ]; then
    echo "Usage: set_aspm_policy [policy]"
    echo "Available policies: default, performance, powersave, powersupersave"
    return 1
  fi

  # Check if the policy provided is valid
  if [[ ! "$policy" =~ ^(default|performance|powersave|powersupersave)$ ]]; then
    echo "Error: invalid policy: $policy"
    echo "Available policies: default, performance, powersave, powersupersave"
    return 1
  fi

  local file="/sys/module/pcie_aspm/parameters/policy" 

  # Check if the file is writable
  if [ -w "$file" ]; then
    # Set the ASPM policy
    echo "$policy" > "$file"
    if [ $? -eq 0 ]; then
      log "ASPM policy set to $policy"
    else
      log "Failed to set ASPM policy"
      return 1
    fi
  else
    log "Cannot write to $file, might require root privileges"
    return 1
  fi
}

set_aspm_feature() {
  local device=$1
  local feature=$2
  local value=$3
  local feature_path="/sys/bus/pci/devices/$device/link/$feature"

  if [ -z "$device" ] || [ -z "$feature" ] || [ -z "$value" ]; then
    echo "Usage: set_aspm_feature <device> <feature> <value>"
    echo "Example: set_aspm_feature 0000:01:00.0 l1_2_aspm 0"
    return 1
  fi

  if [ ! -w "$feature_path" ]; then
    log "Cannot write to $feature_path, might require root privileges"
    return 1
  fi

  # Writing the value to the specified ASPM feature file
  echo "$value" > "$feature_path"
  log "ASPM feature '$feature' set to '$value' for device $device"
}

set_pci_power_control() {
    if [ $# -lt 2 ]; then
        echo "Usage: set_pci_power_control [control_state] [banned_drivers]"
        echo "control_state: 'auto' or 'on'"
        echo "banned_drivers: Comma-separated list of drivers to exclude (e.g., 'driver1,driver2')"
        return 1
    fi

    local control_state="$1"
    local banned_drivers_str="$2"

    # Check if the provided control state is valid
    if [[ "$control_state" != "auto" && "$control_state" != "on" ]]; then
        echo "Invalid control state: $control_state. Allowed values are 'auto' and 'on'"
        return 1
    fi

    # Convert the comma-separated list of banned drivers into an array
    local OIFS=$IFS
    IFS=',' read -r -a banned_drivers <<< "$banned_drivers_str"
    IFS=$OIFS

    local device_driver
    for device_dir in /sys/bus/pci/devices/*; do
        if [ ! -d "$device_dir" ]; then
            continue
        fi

        local device=$(basename "$device_dir")
        local power_state_file="${device_dir}/power_state"
        local control_file="${device_dir}/power/control"
        local driver_link="${device_dir}/driver"

        # if [ ! -f "$power_state_file" ] || [ ! -f "$control_file" ] || [ ! -L "$driver_link" ]; then
        if [ ! -f "$power_state_file" ] || [ ! -f "$control_file" ]; then
            log "Skipping device $device with missing power control"
            continue
        fi

        # Extract the driver name and check if it's in the banned list
        local device_driver=$(readlink "$driver_link")
        local device_driver=$(basename "$device_driver")

        if [[ " ${banned_drivers[*]} " =~ " $device_driver " ]]; then
            log "Skipping device $device with banned driver: $device_driver"
            continue
        fi

        # local power_state=$(cat "$power_state_file")
        # if [ "$power_state" != "unknown" ]; then
        # Check if the file exists and is writable
        if [ -w "$control_file" ]; then
          echo "$control_state" > "$control_file"
          log "PCIe PM control set to '$control_state' for device $device"
        else
          log "Cannot write to $control_file, might require root privileges"
          continue
        fi

        for ata_device_dir in "${device_dir}"/ata*; do
          if [[ ! -e $ata_device_dir ]]; then
            break
          fi
          local ata_device=$(basename "$ata_device_dir")
          local ata_control_file="${ata_device_dir}/power/control"
          if [ -w "$ata_control_file" ]; then
            echo "$control_state" > "$ata_control_file"
            log "PCIe PM control set to '$control_state' for ata device $device/$ata_device"
          else
            log "Cannot write to $ata_control_file, might require root privileges"
            continue
          fi
        done
    done
}

manage_r8125_aspm_conf() {
  local action=$1
  local filePath="/boot/config/modprobe.d/r8125.conf"

  if [ $# -lt 1 ]; then
      echo "Usage: manage_r8125_aspm_conf [aspm_state]"
      echo "aspm_state: 'enable' or 'disable'"
      return 1
  fi

  if [[ "$action" != "enable" && "$action" != "disable" ]]; then
      echo "Invalid action. Specify 'enable' or 'disable'."
      return 1
  fi

  local content="options r8125 aspm=$([[ "$action" == "enable" ]] && echo "1" || echo "0")"
  # Check if the file exists and has the same content
  if [[ ! -f "$filePath" ]] || [[ "$(cat "$filePath")" != "$content" ]]; then
    echo "$content" > "$filePath"
  fi

  log "Set r8125 ASPM to $action"
}

manage_r8168_aspm_conf() {
  local action=$1
  local filePath="/boot/config/modprobe.d/r8168.conf"

  if [ $# -lt 1 ]; then
      echo "Usage: manage_r8168_aspm_conf [aspm_state]"
      echo "aspm_state: 'enable' or 'disable'"
      return 1
  fi

  if [[ "$action" != "enable" && "$action" != "disable" ]]; then
      echo "Invalid action. Specify 'enable' or 'disable'."
      return 1
  fi

  local content="options r8168 aspm=$([[ "$action" == "enable" ]] && echo "1" || echo "0")"
  # Check if the file exists and has the same content
  if [[ ! -f "$filePath" ]] || [[ "$(cat "$filePath")" != "$content" ]]; then
    echo "$content" > "$filePath"
  fi

  log "Set r8169 ASPM to $action"
}

#
# CPU utilities
#

# Expand CPU list range into individual CPUs
expand_cpulist() {
  local range=$1
  local -a cpus=()
  for part in ${range//,/ }; do
    if [[ "$part" == *-* ]]; then
      IFS=- read start end <<< "$part"
      for cpu in $(seq $start $end); do
        cpus+=($cpu)
      done
    else
      cpus+=($part)
    fi
  done
  echo "${cpus[@]}"
}

# Generates a list of CPU ranges from individual CPUs
generate_cpulist() {
  local cpus=("$@")
  local range=""
  local prev_cpu=""
  local -a cpu_ranges=()

  for cpu in "${cpus[@]}"; do
    if [[ -z "$prev_cpu" ]]; then
      range="$cpu"
    elif [[ $((prev_cpu + 1)) -ne $cpu ]]; then
      if [[ "$range" != "$prev_cpu" ]]; then
        range+="-${prev_cpu}"
      fi
      cpu_ranges+=("$range")
      range="$cpu"
    fi
    prev_cpu=$cpu
  done

  # Append the final range
  if [[ -n "$range" ]]; then
    if [[ "$range" != "$prev_cpu" ]]; then
      range+="-${prev_cpu}"
    fi
    cpu_ranges+=("$range")
  fi

  output=$(IFS=,; printf "%s" "${cpu_ranges[*]}")

  echo "$output"
}

# Retrieves the highest CPU number
get_highest_cpu_number() {
    local highest_cpu_num=0
    for cpu_dir in /sys/devices/system/cpu/cpu[0-9]*; do
        local cpu_num="${cpu_dir##*cpu}"
        if (( cpu_num > highest_cpu_num )); then
            highest_cpu_num=$cpu_num
        fi
    done
    echo $highest_cpu_num
}

# Retrieves the NUMA node number for a given network interface
get_numa_node() {
    local interface=$1
    local numa_node_path="/sys/class/net/${interface}/device/numa_node"
    
    if [ ! -f "$numa_node_path" ]; then
        log "NUMA node information not available for $interface"
        echo 0
        return
    fi

    local numa_node
    read  numa_node < "$numa_node_path"
    if [ "$numa_node" -eq -1 ]; then
        # Single node
        echo 0
    else
        echo "$numa_node"
    fi
}

# Retrieves the interrupt numbers associated with a specific device and return the list of CPUs handling those interrupts.
get_device_interrupts_cpus() {
  local device_name=$1

  if [ -z "$device_name" ]; then
    echo "No device name provided"
    return 1
  fi

  # Find interrupt numbers for the device
  local interrupts=$(grep "$device_name" /proc/interrupts | awk '{print $1}' | tr -d ':')
 
  # Loop through each interrupt number to get the effective_affinity_list
  local -a cpu_array=()
  for irq in $interrupts; do
    # Extracting CPU list from effective_affinity_list
    if [ -f "/proc/irq/$irq/effective_affinity_list" ]; then
      local cpus=$(cat /proc/irq/$irq/effective_affinity_list)
      cpus=($(expand_cpulist "$cpus"))
      for cpu in "${cpus[@]}"; do
        # Check if cpu is already in the array
        if [[ ! " ${cpu_array[@]} " =~ " ${cpu} " ]]; then
          cpu_array+=("$cpu")
        fi
      done
    fi
  done

  echo "${cpu_array[@]}"
}

# Groups the CPUs by their performance level
get_cpu_groups_by_perf() {
  # Check for CPPC
  if [ ! -f "/sys/devices/system/cpu/cpu0/acpi_cppc/highest_perf" ]; then
    local present=$(cat "/sys/devices/system/cpu/present")
    echo "$present"    
    return
  fi

  declare -A perf_cpu_map

  for cpu_dir in /sys/devices/system/cpu/cpu[0-9]*/; do
    if [ -f "${cpu_dir}acpi_cppc/highest_perf" ]; then
      local cpu_id=$(basename "$cpu_dir")
      cpu_id=${cpu_id#cpu}
      local perf_value
      read perf_value < "$cpu_dir/acpi_cppc/highest_perf"
      perf_cpu_map[$perf_value]+="${cpu_id} "
    fi
  done

  local -a sorted_cpu_ranges

  for perf in $(echo "${!perf_cpu_map[@]}" | tr ' ' '\n' | sort -nr); do
    local cpus_sorted=($(echo ${perf_cpu_map[$perf]} | tr ' ' '\n' | sort -n))
    local cpu_ranges=$(generate_cpulist "${cpus_sorted[@]}")
    sorted_cpu_ranges+=("$cpu_ranges")
  done

  echo "${sorted_cpu_ranges[@]}"
}

# Get the efficient CPUs
get_efficient_cpus() {
  local -a cpu_array=($(get_cpu_groups_by_perf))
  local cpu_array_size=${#cpu_array[@]}
  
  if [ "$cpu_array_size" -gt 1 ]; then      
    # Hybrid CPU, use efficient
    echo "${cpu_array[1]}"
  else
    # Non hybrid CPU, use normal cores
    echo "${cpu_array[0]}"
  fi    
}

# Retrieves a list of usable CPUs based on the provided network interface and a list of banned CPUs.
get_usable_cpus() {
  local interface=$1
  local -a banned_cpu_array=("${@:2}")

  # Get CPUs associated with the interface
  local local_cpulist=$(cat /sys/class/net/"$interface"/device/local_cpulist)
  local -a local_cpu_array=($(expand_cpulist "$local_cpulist"))

  # Get efficent CPUs
  local e_cpu_array=($(expand_cpulist "$(get_efficient_cpus)"))

  # Filter out banned and not preferred CPUs
  local -a cpu_array=()
  for cpu in "${local_cpu_array[@]}"; do
    if [[ " ${e_cpu_array[@]} " =~ " ${cpu} " ]] && ! [[ " ${banned_cpu_array[@]} " =~ " ${cpu} " ]]; then
      cpu_array+=("$cpu")
    fi
  done

  echo "${cpu_array[@]}"
}

#
# NIC irq affinity settings
#

# Validates the input parameters for affinity functions
validate_affinity_function_params() {
  local interface="$1"
  local first_cpu="$2"
  local cpu_array=("${@:3}")

  if [[ -z "$interface" || -z "$first_cpu" || -z "${cpu_array[*]}" ]]; then
    echo "Usage: set_interrupt_affinity [interface] [first_cpu] [cpu_array]"
    echo "interface: Network interface (e.g., eth0)"
    echo "first_cpu: First CPU to assign the first interrupt"
    echo "cpu_array: Array of CPUs to use"
    return 1
  fi

  if ! [[ $first_cpu =~ ^[0-9]+$ ]]; then
    log_message "Error: first_cpu is not a valid number."
    return 1
  fi

  return 0
}

# Set the CPU affinity for a specific interrupt and rx/tx queue
set_nic_interrupt_affinity() {
  local interface=$1
  local irq=$2
  local queue_num=$3
  local cpu=$4

  echo $cpu > /proc/irq/"$irq"/smp_affinity_list
  printf "%x" $((1 << $cpu)) > /sys/class/net/"$interface"/queues/tx-$queue_num/xps_cpus
  log "Set CPU affinity of interrupt $irq and tx queue $queue_num of $interface to CPU $cpu"
}

set_rtl8125_interrupt_affinity() {
  local interface=$1
  local first_cpu=$2
  local -a cpu_array=("${@:3}")
 
  if ! validate_affinity_function_params "$@"; then
    return 1
  fi

  # RX queue count
  local rx_queue_count=$(ls -d /sys/class/net/"$interface"/queues/rx-* | wc -l)

   # Find the interrupts associated with the given network interface
  local interrupts=($(grep -i "$interface" /proc/interrupts | awk '{print $1}' | tr -d ':'))
  local irq_count=${#interrupts[@]}

  if [ "$irq_count" -eq 0 ]; then
    log "No interrupts found for interface $interface"
    return 1
  fi

  # Check for valid rtl8125 interrupt configuration
  if [  "$irq_count" -lt 32 ]; then
    log "Unknown RTL8125 interrupt configuration for interface $interface"
    return 1
  fi

  if [ "$irq_count" -lt "$rx_queue_count" ]; then
    log "The number of interrupts $irq_count is less than the number of rx queues ($rx_queue_count) for interface $interface"
    return 1
  fi

  # TX queue count
  local tx_queue_count=$(ls -d /sys/class/net/"$interface"/queues/tx-* | wc -l)

  # The interrupts associated with the tx queues are fixed
  local tx_interrupts
  if [ "$tx_queue_count" -eq 1 ]; then
    tx_interrupts=("${interrupts[16]}")  
  elif [ "$tx_queue_count" -eq 2 ]; then
    tx_interrupts=("${interrupts[16]}" "${interrupts[18]}")  
  else
    log "Unknown RTL8125 tx queue configuration for interface $interface"
    return 1
  fi  

  # Find first CPU
  local first_cpu_index=0
  for i in "${!cpu_array[@]}"; do
    if [[ "${cpu_array[$i]}" -ge "$first_cpu" ]]; then
      first_cpu_index=$i
      break
    fi
  done

  # Set the CPU affinity for each interrupt for rx queues, cycling through available CPU cores
  local queue_num=0
  local current_cpu_index=$first_cpu_index
  for irq in "${interrupts[@]}"; do
    if [ "$queue_num" -ge "$rx_queue_count" ]; then
      break
    fi

    echo ${cpu_array[$current_cpu_index]} > /proc/irq/"$irq"/smp_affinity_list
    log "Set CPU affinity of interrupt $irq and rx queue $queue_num of $interface to CPU ${cpu_array[$current_cpu_index]}"

    queue_num=$((queue_num + 1))

    # Prepare the next CPU
    current_cpu_index=$((current_cpu_index + 1))
    if [ $current_cpu_index -ge  ${#cpu_array[@]} ]; then
      current_cpu_index=0
    fi
  done

  # Set the CPU affinity for each interrupt and corresponding xps_cpus for tx queues, cycling through available CPU cores
  local queue_num=0
  local current_cpu_index=$first_cpu_index
  # rx queue count can be same as tx queue count or twice the number of tx queues
  local step=$((rx_queue_count / tx_queue_count))
  for irq in "${tx_interrupts[@]}"; do
    if [ "$queue_num" -ge "$tx_queue_count" ]; then
      break
    fi

    local cpu_mask=0
    local cpu_str=""
    for ((i = 1; i <= step; i++)); do
      cpu_mask=$(($cpu_mask | 1 << ${cpu_array[$current_cpu_index]}))
      cpu_str+="${cpu_array[$current_cpu_index]} "
      # Prepare the next CPU
      current_cpu_index=$((current_cpu_index + 1))
      if [ $current_cpu_index -ge ${#cpu_array[@]} ]; then
        current_cpu_index=0
      fi
    done
    local cpu_mask_hex=$(printf "%x" $cpu_mask)
    
    echo $cpu_mask_hex > /proc/irq/"$irq"/smp_affinity
    echo $cpu_mask_hex > /sys/class/net/"$interface"/queues/tx-$queue_num/xps_cpus
    log "Set CPU affinity of interrupt $irq and tx queue $queue_num of $interface to CPU $cpu_str"

    queue_num=$((queue_num + 1))
  done

  echo "${cpu_array[$current_cpu_index]}"
  return 0
}

set_intel_nic_interrupt_affinity() {
  local interface=$1
  local first_cpu=$2
  local -a cpu_array=("${@:3}")

  if ! validate_affinity_function_params "$@"; then
    return 1
  fi

  # RX queue count
  local rx_queue_count=$(ls -d /sys/class/net/"$interface"/queues/rx-* | wc -l)

   # Find the interrupts associated with the given network interface
  local interrupts=($(grep -i "$interface-.*TxRx" /proc/interrupts | awk '{print $1}' | tr -d ':'))
  local irq_count=${#interrupts[@]}

  if [ "$irq_count" -eq 0 ]; then
    log "No interrupts found for interface $interface"
    return 1
  fi

  if [ "$irq_count" -lt "$rx_queue_count" ]; then
    log "The number of interrupts irq_count is less than the number of rx queues ($rx_queue_count) for interface $interface"
    return 1
  fi

  # Find first CPU
  local first_cpu_index=0
  for i in "${!cpu_array[@]}"; do
    if [[ "${cpu_array[$i]}" -ge "$first_cpu" ]]; then
      first_cpu_index=$i
      break
    fi
  done

  # Set the CPU affinity for each interrupt for rx queues, cycling through available CPU cores
  local queue_num=0
  local current_cpu_index=$first_cpu_index
  for irq in "${interrupts[@]}"; do
    if [ "$queue_num" -ge "$rx_queue_count" ]; then
      break
    fi
    
    set_nic_interrupt_affinity $interface $irq $queue_num ${cpu_array[$current_cpu_index]}

    queue_num=$((queue_num + 1))

    # Prepare the next CPU, respecting the max CPU index
    current_cpu_index=$((current_cpu_index + 1))
    if [ $current_cpu_index -ge  ${#cpu_array[@]} ]; then
      current_cpu_index=0
    fi
  done

  echo "${cpu_array[$current_cpu_index]}"
  return 0
}

set_generic_nic_interrupt_affinity() {
  local interface=$1
  local first_cpu=$2
  local -a cpu_array=("${@:3}")

  if ! validate_affinity_function_params "$@"; then
    return 1
  fi

  # RX queue count
  local rx_queue_count=$(ls -d /sys/class/net/"$interface"/queues/rx-* | wc -l)

  if [ "$rx_queue_count" -ne 1 ]; then
    log "Unknown rx queue configuration for interface $interface"
    return 1
  fi

   # Find the interrupt associated with the given network interface
  local interrupts=($(grep -i "$interface" /proc/interrupts | awk '{print $1}' | tr -d ':'))
  local irq_count=${#interrupts[@]}

  if [ "$irq_count" -eq 0 ]; then
    log "No interrupts found for interface $interface"
    return 1
  fi

  if [ "$irq_count" -ne 1 ]; then
    log "Unknown interrupt configuration for interface $interface"
    return 1
  fi

  # Find first CPU
  local first_cpu_index=0
  for i in "${!cpu_array[@]}"; do
    if [[ "${cpu_array[$i]}" -ge "$first_cpu" ]]; then
      first_cpu_index=$i
      break
    fi
  done

  # Set the CPU affinity for the rx and tx queue
  local queue_num=0
  local current_cpu_index=$first_cpu_index
  local irq="${interrupts[0]}"

  set_nic_interrupt_affinity $interface $irq $queue_num ${cpu_array[$current_cpu_index]}

  # Prepare the next CPU, respecting the max CPU index
  current_cpu_index=$((current_cpu_index + 1))
  if [ $current_cpu_index -ge  ${#cpu_array[@]} ]; then
    current_cpu_index=0
  fi

  echo "${cpu_array[$current_cpu_index]}"
  return 0
}

# Get the vendor of the network interface
get_nic_type() {
  local interface=$1

  if [ -z "$interface" ]; then
    echo "Usage: get_nic_vendor [interface]"
    return 1
  fi

  # Get the PCI location of the network interface
  local pci_location=$(grep -oP 'PCI_SLOT_NAME=\K.*' < /sys/class/net/"$interface"/device/uevent)
 
  if [ -z "$pci_location" ]; then
    log "Could not determine the PCI location of $interface"
    return 1
  fi

  # Extract the vendor information for the network interface
  local vendor=$(lspci -s "$pci_location" -v | grep -oP 'Ethernet controller: \K.*')

  if [ -n "$vendor" ]; then
    echo "$vendor"
    return 0
  else
    log "Vendor information not found for $interface"
    return 1
  fi
}

# Get the driver of the network interface
get_nic_driver() {
  local interface=$1

  if [ -z "$interface" ]; then
    echo "Usage: get_nic_vendor [interface]"
    return 1
  fi

  # Get the driver of the network interface
  local nic_driver=$(grep -oP 'DRIVER=\K.*' < /sys/class/net/"$interface"/device/uevent)
 
  if [ -n "$nic_driver" ]; then
    echo "$nic_driver"
    return 0
  else
    log "Could not determine the driver of $interface"
    return 1
  fi
}

optimize_nic_interrupt_affinity() {
  local banned_device_list=$1
  
  # Convert the comma-separated list of banned drivers into an array
  IFS=',' read -r -a banned_device_array <<< "$banned_device_list"

  # CPU0 is always banned
  local -a banned_cpu_array=(0)

  # Get efficent CPUs
  local -a e_cpu_array=($(expand_cpulist "$(get_efficient_cpus)"))
  local e_cpu_array_size=${#e_cpu_array[@]}
  local max_cpu=$(get_highest_cpu_number + 1)

  # Only take into account banned devices if there are at least 4 efficent CPUs
  if (( e_cpu_array_size >= 4 )); then  
    for banned_device in "${banned_device_array[@]}"; do
      local -a to_ban=($(get_device_interrupts_cpus "$banned_device"))
      banned_cpu_array=("${banned_cpu_array[@]}" "${to_ban[@]}")
    done
    log "Banned CPUs for network interface interrupt affinity: $(generate_cpulist "${banned_cpu_array[@]}")"
  fi

  for interface in /sys/class/net/*; do
    # Extract just the interface name, not the full path
    local interface_name=$(basename "$interface")

    # Check if it's a physical device
    if [ ! -d "/sys/class/net/$interface_name/device" ]; then
      continue
    fi

    # Usable CPUs
    local -a cpu_array_no_ban=($(get_usable_cpus "$interface_name" "0"))
    local -a cpu_array=($(get_usable_cpus "$interface_name" "${banned_cpu_array[@]}"))
    local cpu_array_size=${#cpu_array[@]}
 
    log "Usable CPUs for $interface_name: $(generate_cpulist "${cpu_array[@]}")"

    local numa_node=$(get_numa_node "$interface_name")
    local first_cpu=${first_cpu_map[$numa_node]:-0}

    local nic_driver=$(get_nic_driver "$interface_name")
    local nic_type=$(get_nic_type "$interface_name")

    local ret

    # Set the NIC interrupt affinity using some heuristics  
    if [[ "$nic_driver" == "r8125" ]]; then
      if (( (max_cpu <= 4 && cpu_array_size >= 2) || (max_cpu <= 6 && cpu_array_size >= 3) || cpu_array_size >= 4 )); then
        ret=$(set_rtl8125_interrupt_affinity "$interface_name" "$first_cpu" "${cpu_array[@]}")
      else
        ret=$(set_rtl8125_interrupt_affinity "$interface_name" "$first_cpu" "${cpu_array_no_ban[@]}")
      fi
    elif [[ "$nic_type" =~ Intel.* ]]; then
      if (( cpu_array_size >= 4 )); then
        ret=$(set_intel_nic_interrupt_affinity "$interface_name" "$first_cpu" "${cpu_array[@]}")
      else
        ret=$(set_intel_nic_interrupt_affinity "$interface_name" "$first_cpu" "${cpu_array_no_ban[@]}")
      fi
      if [ $? -ne 0 ]; then
        # Retry with generic
        ret=$(set_generic_nic_interrupt_affinity "$interface_name" "$first_cpu" "${cpu_array[@]}")
      fi
    else
      ret=$(set_generic_nic_interrupt_affinity "$interface_name" "$first_cpu" "${cpu_array[@]}")
    fi

    if [ $? -eq 0 ]; then
        first_cpu_map[$numa_node]=$ret  # Update first_cpu if there was no error
    fi

  done
}

#
# TCP stack settings
#

get_max_interface_speed() {
    local max_speed=0

    # Loop through all available network interfaces
    for interface_path in /sys/class/net/*; do
      local interface=$(basename "$interface_path")

      # Check if it's a physical device
      if [ ! -d "/sys/class/net/$interface/device" ]; then
        continue
      fi

      # Get the speed of the current interface using ethtool
      local speed=$(ethtool "$interface" 2>/dev/null | grep 'Speed:' | awk '{print $2}' | sed 's/Mb\/s//')

      # Proceed only if speed is a number (ignoring interfaces without a speed value)
      if ! [[ $speed =~ ^[0-9]+$ ]]; then
        continue
      fi

      # Compare and store the max speed
      if [ "$speed" -gt "$max_speed" ]; then
        max_speed=$speed
      fi
    done

    # Return the maximum speed found
    echo "$max_speed"
}

# Optimize TCP setting based on the maximum interface speed
optimize_tcp() {
  local max_speed=$(get_max_interface_speed)
    
  log "Maximum interface speed: $max_speed Mb/s"

  # Based on the speed, execute different commands
  case $max_speed in
    1000)
      # Setting maximum TCP read and write buffer sizes to 16MB
      sysctl -w net.core.rmem_max=16777216 > /dev/null
      sysctl -w net.core.wmem_max=16777216 > /dev/null
      # Increasing the Linux autotuning TCP buffer limits to 16MB
      sysctl -w net.ipv4.tcp_rmem="4096 87380 16777216" > /dev/null
      sysctl -w net.ipv4.tcp_wmem="4096 65536 16777216" > /dev/null            
      ;;
    2500)
      # Setting maximum TCP read and write buffer sizes to 32MB
      sysctl -w net.core.rmem_max=33554432  > /dev/null
      sysctl -w net.core.wmem_max=33554432  > /dev/null
      # Increasing the Linux autotuning TCP buffer limits to 32MB
      sysctl -w net.ipv4.tcp_rmem="4096 87380 33554432" > /dev/null
      sysctl -w net.ipv4.tcp_wmem="4096 65536 33554432" > /dev/null 
      ;;
    5000)
      # Setting maximum TCP read and write buffer sizes to 32MB
      sysctl -w net.core.rmem_max=33554432  > /dev/null
      sysctl -w net.core.wmem_max=33554432  > /dev/null
      # Increasing the Linux autotuning TCP buffer limits to 32MB
      sysctl -w net.ipv4.tcp_rmem="4096 87380 33554432" > /dev/null
      sysctl -w net.ipv4.tcp_wmem="4096 65536 33554432" > /dev/null 
      ;;
    10000)
      # Setting maximum TCP read and write buffer sizes to 64MB
      sysctl -w net.core.rmem_max=67108864 > /dev/null
      sysctl -w net.core.wmem_max=67108864 > /dev/null
      # Increasing the Linux autotuning TCP buffer limits to 32MB
      sysctl -w net.ipv4.tcp_rmem="4096 87380 33554432" > /dev/null
      sysctl -w net.ipv4.tcp_wmem="4096 65536 33554432" > /dev/null 
      # Disable slow start
      sysctl -w net.ipv4.tcp_slow_start_after_idle=0 > /dev/null   
      ;;
     *)
      echo "No specific optimization for this speed: $max_speed Mb/s"
      ;;
    esac  

  # Enabling TCP MTU Probing
  sysctl -w net.ipv4.tcp_mtu_probing=1 > /dev/null

  log "TCP parameters optimized"
}

# Restore TCP parameters
restore_tcp() {
  sysctl -w net.core.rmem_max=33554432 > /dev/null
  sysctl -w net.core.wmem_max=33554432 > /dev/null
  sysctl -w net.ipv4.tcp_rmem="4096 87380 33554432" > /dev/null
  sysctl -w net.ipv4.tcp_wmem="4096 65536 33554432" > /dev/null
  sysctl -w net.ipv4.tcp_mtu_probing=0 > /dev/null
 
  log "Restored TCP parameters"
 }

#
# Kernel parameter functions
#

# Set a kernel command line parameter
set_kernel_parameter() {
    local paramName=$1
    local paramValue=$2
    local configFile="/boot/syslinux/syslinux.cfg"
    local tempFile=$(mktemp)

    # Check if the parameter name or value is empty
    if [[ -z "$paramName" ]] || [[ -z "$paramValue" ]]; then
        echo "Usage: add_kernel_parameter [parameter name] [parameter value]"
        echo "Parameter name or value is missing."
        return 1
    fi

    # Check if the configuration file exists
    if [[ ! -f "$configFile" ]]; then
        log "Configuration file does not exist at $configFile."
        return 1
    fi

    # Use awk to either add or update the parameter in the kernel line
    awk -v paramName="$paramName" -v paramValue="$paramValue" '
    /label Unraid OS/ {
        print;  # Print the "label" line
        getline; print;  # Print the "menu" line
        getline;  # Process the "kernel" line
        if ($1 == "kernel") {
            # Check if parameter is already in the line
            if (index($0, paramName "=") > 0) {
                # Parameter exists, replace its value
                gsub(paramName "=[^ ]+", paramName "=" paramValue);
            } else {
                # Parameter doesnt exist, append it
                $0 = $0 " " paramName "=" paramValue;
            }
            print;
        } else {
            print;
        }
        next;
    }
    { print }  # Print lines that do not match the "label Unraid OS" block
    ' "$configFile" > "$tempFile"

    # Check if changes were made. If so, update the configFile.
    if ! cmp --silent "$tempFile" "$configFile"; then
        log "Added kernel boot parameter: $paramName=$paramValue"
        mv "$tempFile" "$configFile"
    else
        log "Kernel boot parameter is already set: $paramName=$paramValue"
        rm "$tempFile"  # No change, so remove the temporary file
    fi
}

# Remove a kernel command line parameter
remove_kernel_parameter() {
    local paramName=$1
    local configFile="/boot/syslinux/syslinux.cfg"
    local tempFile=$(mktemp)

    # Check if the parameter name or value is empty
    if [[ -z "$paramName" ]]; then
        echo "Usage: remove_kernel_parameter [parameter name]"
        echo "Parameter name is missing."
        return 1
    fi

    # Check if the configuration file exists
    if [[ ! -f "$configFile" ]]; then
        log "Configuration file does not exist at $configFile."
        return 1
    fi

    # Use awk to either add or update the parameter in the kernel line
    awk -v paramName="$paramName" -v paramValue="$paramValue" '
    /label Unraid OS/ {
        print;  # Print the "label" line
        getline; print;  # Print the "menu" line
        getline;  # Process the "kernel" line
        if ($1 == "kernel") {
            # Check if parameter is in the line
            if (index($0, paramName "=") > 0) {
                # Parameter exists, remove it
                gsub(" " paramName "=[^ ]+", "");
            }
            print;
        } else {
            print;
        }
        next;
    }
    { print }  # Print lines that do not match the "label Unraid OS" block
    ' "$configFile" > "$tempFile"

    # Check if changes were made. If so, update the configFile.
    if ! cmp --silent "$tempFile" "$configFile"; then
        log "Removed kernel boot parameter: $paramName"
        mv "$tempFile" "$configFile"
    else
        rm "$tempFile"  # No change, so remove the temporary file
    fi
}

# Get a kernel command line parameter value
get_kernel_parameter() {
    local paramName=$1
    local configFile="/boot/syslinux/syslinux.cfg"

    # Check if the parameter name or value is empty
    if [[ -z "$paramName" ]]; then
        echo "Usage: get_kernel_parameter [parameter name]"
        echo "Parameter name is missing."
        return 1
    fi

    # Check if the configuration file exists
    if [[ ! -f "$configFile" ]]; then
        log "Configuration file does not exist at $configFile."
        return 1
    fi

    # Use awk to either add or update the parameter in the kernel line
    local value
    value=$(awk -v paramName="$paramName" '
    BEGIN { foundParam = 0; }
    /label Unraid OS/ {
        getline; # Skip the "menu" line
        getline;  # Process the "kernel" line
        if ($1 == "kernel") {
            # Check if parameter is in the line
            regex = paramName "=([^[:space:]]+)";
            if (match($0, regex, arr)) {
                print arr[1];
                foundParam = 1;
                exit 0;
            }              
        } 
        next;
    }
    END { if (foundParam == 0) { exit 1; } }
    ' "$configFile")

    if [ $? -eq 0 ]; then
      echo "$value"
      return 0
    else
      return 1
    fi
}

#
# Housekeeping functions
#
optimize_houskeeping() {
  local -a cpu_array=($(get_cpu_groups_by_perf))
  local cpu_array_size=${#cpu_array[@]}

  # Move interrupts to efficient cores on hybrid CPUs
  if [ "$cpu_array_size" -gt 1 ]; then      
    set_kernel_parameter "irqaffinity" "${cpu_array[1]}"
  fi    

  # Offload RCUs from IRQs
  set_kernel_parameter "rcu_nocbs" "0-$(get_highest_cpu_number)"

  # Enable nohz full on all cores
  # set_kernel_parameter "nohz_full "0-$(get_highest_cpu_number)"

  set_kernel_parameter "nmi_watchdog" "0"
}

restore_houskeeping() {
  remove_kernel_parameter "irqaffinity"
  remove_kernel_parameter "rcu_nocbs"
  # remove_kernel_parameter "nohz_full"
  remove_kernel_parameter "nmi_watchdog"
}

#
# Diagnostics functions
#

#Function to check PCIe bridge Link Power Management state
diag_pcie_bridge_lpm() {
  local PCI_SYSFS="/sys/bus/pci/devices"
  local PCI_BRIDGE_CLASS="0x060400"
  local devices=$(ls ${PCI_SYSFS})
  local -a bridge_devices=()

  # Get list of pci bridge devices
  for dev in $devices; do
    if [ -d "${PCI_SYSFS}"/"${dev}" ] &&
      [ -f "${PCI_SYSFS}"/"${dev}"/config ]; then
      class=$(cat "${PCI_SYSFS}"/"${dev}"/class)
      if [[ "${class}" == "${PCI_BRIDGE_CLASS}" ]]; then
        bridge_devices+=("${dev}")
      fi
    fi
  done

  link_state() {
    local pciests1=$1
    local byte1="$((16#${pciests1} >> 8))"
    local ltsmstate="$((16#${pciests1} & 255))"
    local l1msg="Link is in L1"
    local policy=""

    # Some bit manipulation to get Link Status
    lnkstat=$(((byte1 >> 3) & 15))

    case "${lnkstat}" in
    0)
      case "${ltsmstate}" in
      [0-9] | 1[0-6])
        l1msg="Link is in Detect"
        ;;
      4[2-9])
        l1msg="Link is in L2, LTSMSTATE=0"
        ;;
      59 | 60 | 61)
        l1msg="Link is Disabled"
        ;;
      *)
        l1msg="Link is not in Low Power State, LTSMSTATE=${ltsmstate}"
        ;;
      esac
      echo "${l1msg}"
      ;;
    1)
      echo "Link is Retraining"
      ;;
    3)
      case "${ltsmstate}" in
      5[5-9] | 60)
        l1msg="Link is in L1"
        ;;
      61 | 62)
        l1msg="Link is in L1.1"
        ;;
      63 | 64)
        l1msg="Link is in L1.2"
        ;;
      *)
        l1msg="Link is other L1 state, LTSMSTATE=${ltsmstate}"
        ;;
      esac
      echo "${l1msg}"
      ;;
    4)
      echo "Link is in L2"
      ;;
    5)
      echo "Link is in L3"
      ;;
    [7-9] | 10)
      echo "Link is in L0"
      ;;
    *)
      echo "Unknown link state ${lnkstat}"
      ;;
    esac
  }

  # echo "Available PCI bridge devices:" "${bridge_devices[@]}"
  for dev in "${bridge_devices[@]}"; do
    #Get lower 16 bits of PCIESTS1 register
    local pciests1=$(od -v -j 810 -N 2 -A none --endian=big -t x2 "${PCI_SYSFS}"/"${dev}"/config | sed 's/^[[:space:]]*//')
    echo "$dev $(link_state "${pciests1}")"
  done
}

diag_aspm_status () {
  lspci -vv 2>/dev/null | awk '/Power Management.*?/{print $0}' RS= | grep --color -P '(^[a-z0-9:.]+|D0[+-]*|D1[+-]*|D2[+-]*|D3[a-z+-]*|ASPM.*?abled|ASPM_[^ ]*|ASPM L[^,]*)'
}

#
# Main apply function 
#

apply () {
  log "Appply $POWER_PROFILE profile"

  case "$POWER_PROFILE" in
    "performance")
      set_scaling_governor "performance"
      set_cpu_performance_preference "performance"
      ;;
    "balanced")
      file="/sys/devices/system/cpu/cpu0/cpufreq/scaling_available_governors"
      if [ -r "$file" ] && grep -q "schedutil" "$file"; then
        set_scaling_governor "schedutil"
      else
        set_scaling_governor "powersave"
      fi
      set_cpu_performance_preference "balance_performance"
      ;;
    "powersave")
      set_scaling_governor "powersave"
      set_cpu_performance_preference "balance_power"
      ;;
    "powersupersave")
      set_scaling_governor "powersave"
      set_cpu_performance_preference "power"
  esac

  set_dynamic_boost 1
  set_no_turbo 0
  
  set_aspm_policy "$ASPM_POLICY"

  if [ "$PCI_PM_CONTROL" != "default" ]; then
    set_pci_power_control "$PCI_PM_CONTROL" "$PCI_PM_BANNED"
  fi

  if lsmod | grep -q "r8125"; then
    manage_r8125_aspm_conf "$R8125_ASPM"
  fi

  if lsmod | grep -q "r8168"; then
    manage_r8168_aspm_conf "$R8168_ASPM"
  fi

  if [ "$TWEAK_NIC_IRQ" = "enable" ]; then
    optimize_nic_interrupt_affinity "$NIC_IRQ_BANNED"
  fi
 
  if [ "$TWEAK_TCP" = "enable" ]; then
    optimize_tcp
  else
    restore_tcp
  fi

  if [ "$TWEAK_HK" = "enable" ]; then
    optimize_houskeeping
  else
    restore_houskeeping
  fi

  if [ "$KERNEL_PREFERRED_CSTATES" = "default" ]; then
    remove_kernel_parameter "intel_idle.preferred_cstates"
  else
    set_kernel_parameter "intel_idle.preferred_cstates" "$KERNEL_PREFERRED_CSTATES"
  fi

  if [ "$KERNEL_MITIGATIONS" = "default" ]; then
    remove_kernel_parameter "mitigations"
  else
    set_kernel_parameter "mitigations" "$KERNEL_MITIGATIONS"
  fi

}

# Unapply before uninstall
unapply () {
  log "Unappply autotweak settings"
  
  set_scaling_governor "performance"
  set_cpu_performance_preference "performance"
  set_dynamic_boost 0
  set_aspm_policy "default"

  restore_tcp
  restore_houskeeping
  remove_kernel_parameter "intel_idle.preferred_cstates"
  remove_kernel_parameter "mitigations"

  rm -f "/boot/config/modprobe.d/r8125.conf"
  rm -f "/boot/config/modprobe.d/r8168.conf"
}

# Execute the function with all arguments  
executeFunction() {
  local func_name=$1
  shift  # Remove the first argument (function name), leaving only the function's arguments

  if declare -f "$func_name" > /dev/null; then
      # Call the function passing all remaining command line arguments
      $func_name "$@"
  else
      echo "Error: Function '$func_name' not found"
      exit 1
  fi
}

# Check if the function name is provided as an argument
if [ -z "$1" ]; then
    echo "Usage: $0 <function_name>"
    exit 1
fi


# Read default config
if [ -f "/etc/autotweak/default.cfg" ]; then
  source "/etc/autotweak/default.cfg"
  CONFIG="/etc/autotweak/autotweak.cfg"
else
  source /usr/local/emhttp/plugins/autotweak/default.cfg
  CONFIG="/boot/config/plugins/autotweak/autotweak.cfg"
fi

# Check if the file exists and is readable
if [ -r "$CONFIG" ]; then
  source "$CONFIG"
fi

# Execute the function with all arguments
executeFunction "$@"